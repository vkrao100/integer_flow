/*------------------------------------------------------------------------*/
/* Copyright (C) 2020, Daniela Kaufmann, Johannes Kepler University Linz    */
/*------------------------------------------------------------------------*/
#define VERSION "001"

static const char * usage =
"nusschecker [ <option> ... ]  [ <polynomials> <cofactor>] [<spec>]\n"
"\n"
"where <option> is one of the following\n"
"\n"
"  -h | --help            print this command line option summary and exit\n"
"\n"
"  -t | --no-target       only calculate final sum but not that proof generates target\n"
"\n"
"  -v | --verbose         get verbose output on number of checked inferences (beep every 500 rules)\n"
"\n"
"  -e | --use-exponents   turn off implicit reduction of exponents\n"
"\n"
"  -a0                    addition in tree approach, depth first\n"
"  -a1                    addition in tree approach, breadth first\n"
"  -a2                    addition in sequence\n"
"  -a3                    addition by sorting one single stack\n"
"\n"
"  -s0                    sort variables according to  strcmp (default)\n"
"  -s1                    sort variables according to -1*strcmp \n"
"  -s2                    sort variables according to input order\n"
"  -s3                    sort variables according to reverse input order\n"
"\n"
"The <polynomials> argument should point to a file with the\n"
"original set of polynomials and <cofactor> is a path to a file\n"
"containing the co-factors of the Nullstellensatz proof.\n"
"\n"
"The <spec> is optional. Ommiting this file has the same effect as choosing option '-t'\n"
"It should point to a file with a single polynomial which\n"
"should be generated by the proof.\n"
;

/*------------------------------------------------------------------------*/

#include <assert.h>
#include <ctype.h>
#include <inttypes.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <gmp.h>

#ifdef HAVEGETRUSAGE
#include <sys/time.h>
#include <sys/resource.h>
#endif
/*------------------------------------------------------------------------*/
static int check_target = 1;
static int verbose = 0;
static int exponents = 0;
static int addition = 0;
static int sort = 0;

static char * poly_file_name = 0;
static char * cofactor_file_name = 0;
static char * target_file_name = 0;

static FILE * poly_file;
static FILE * cofactor_file;
static FILE * target_file;


// error and verbose messages

static void die (const char * msg, ...) {
  fflush (stdout);
  fprintf (stderr, "*** 'NUSS-Checker' error: ");
  va_list ap;
  va_start (ap, msg);
  vfprintf (stderr, msg, ap);
  va_end (ap);
  fprintf (stderr, "\n");
  fflush (stderr);
  exit (1);
}

static void msg (const char * msg, ...) {
  fprintf (stdout, "[NC] ");
  va_list ap;
  va_start (ap, msg);
  vfprintf (stdout, msg, ap);
  va_end (ap);
  fprintf (stdout, "\n");
  fflush (stdout);
}


/*------------------------------------------------------------------------*/

// memory management routines maintaining a count of allocated memory

static size_t current_allocated_bytes;
static size_t max_allocated_bytes;

static void inc_allocated_bytes (size_t bytes) {
  current_allocated_bytes += bytes;
  if (current_allocated_bytes > max_allocated_bytes)
    max_allocated_bytes = current_allocated_bytes;
}

static void dec_allocated_bytes (size_t bytes) {
  assert (current_allocated_bytes >= bytes);
  current_allocated_bytes -= bytes;
}

static void * allocate (size_t bytes) {
  if (!bytes) return 0;
  void * res = malloc (bytes);
  if (bytes) {
    if (res) memset (res, 0, bytes);
    else die ("out-of-memory allocating %zu bytes", bytes);
  }
  inc_allocated_bytes (bytes);
  return res;
}

static void deallocate (void * ptr, size_t bytes) {
  dec_allocated_bytes (bytes);
  free (ptr);
}

static void * reallocate (void * ptr, size_t old_bytes, size_t new_bytes) {
  dec_allocated_bytes (old_bytes);
  void * res = realloc (ptr, new_bytes);
  if (res) {
    if (new_bytes > old_bytes)
      memset (res + old_bytes, 0, new_bytes - old_bytes);
  } else die ("out-of-memory reallocating %zu bytes", new_bytes);
  inc_allocated_bytes (new_bytes);
  return res;
}

/*------------------------------------------------------------------------*/

// 'polymorphic' array management routine maintain a count of allocated memory

#define ALLOCATE(P,N) \
do { \
  size_t BYTES = (N) * sizeof *(P); \
  (P) = allocate (BYTES); \
} while (0)

#define DEALLOCATE(P,N) \
do { \
  size_t BYTES = (N) * sizeof *(P); \
  deallocate ((P), BYTES); \
} while (0)

#define REALLOCATE(P,O,N) \
do { \
  size_t OLD_BYTES = (O) * sizeof *(P); \
  size_t NEW_BYTES = (N) * sizeof *(P); \
  (P) = reallocate ((P), OLD_BYTES, NEW_BYTES); \
} while (0)

/*------------------------------------------------------------------------*/

// some smaller helper macros

#define SWAP(TYPE,A,B) \
do { \
  TYPE TMP = (A); \
  (A) = (B); \
  (B) = TMP; \
} while (0)

#define MAX(A,B) \
  ((A) < (B) ? (B) : (A))

/*------------------------------------------------------------------------*/

// Random odd 64 numbers for constructing hash functions.

static uint64_t nonces[32];
static const size_t num_nonces = sizeof nonces / sizeof nonces[0];

static uint16_t rand16 () {
  int tmp = rand ();
  assert (tmp >= 0);
  uint16_t res = tmp ^ (tmp >> 16);
  return res;
}

static uint64_t rand64 () {
  uint64_t res = 0;
  for (unsigned i = 0; i < 64; i += 16)
    res |= rand16 () << i;
  return res;
}

static void init_nonces () {
  srand (42);
  for (size_t i = 0; i < num_nonces; i++)
    nonces[i] = rand64 () | 1;
}

/*------------------------------------------------------------------------*/

// String functions.

static char * duplicate_string (const char * str) {
  if (!str) return 0;
  size_t bytes = strlen (str) + 1;
  char * res = allocate (bytes);
  assert(res);
  strcpy (res, str);
  return res;
}

static void deallocate_string (char * str) {
  deallocate (str, strlen (str) + 1);
}

static uint64_t hash_string (const char * str) {
  uint64_t res = 0;
  size_t i = 0;
  for (const char * p = str; *p; p++) {
    res += *p;
    res *= nonces[i++];
    if (i == num_nonces) i = 0;
  }
  return res;
}

/*------------------------------------------------------------------------*/

// Variables are kept canonical using a global hash table similar to a
// symbol table in an ordinary compiler.

typedef struct Variable Variable;

struct Variable {
  char * name;			// variable name
  uint64_t hash;		// saved hash value
  Variable * next;		// hash collision chain link
  int count;
  uint64_t level;

};

static uint64_t num_variables;
static uint64_t size_variables;
static Variable ** variable_table;

static void enlarge_variables () {
  uint64_t new_size_variables = size_variables ? 2*size_variables : 1;
  Variable ** new_variable_table;
  ALLOCATE (new_variable_table, new_size_variables);
  for (uint64_t i = 0; i < size_variables; i++) {
    for (Variable * v = variable_table[i], * n; v; v = n) {
      uint64_t h = v->hash & (new_size_variables - 1);
      n = v->next;
      v->next = new_variable_table[h];
      new_variable_table[h] = v;
    }
  }
  DEALLOCATE (variable_table, size_variables);
  variable_table = new_variable_table;
  size_variables = new_size_variables;
}

static int is_valid_variable_letter (char ch) {
  if (ch == '_') return 1;
  if ('0' <= ch && ch <= '9') return 1;
  if ('a' <= ch && ch <= 'z') return 1;
  if ('A' <= ch && ch <= 'Z') return 1;
  return 0;
}

static int is_valid_variable_first_letter (char ch) {
  if (ch == '_') return 1;
  if ('a' <= ch && ch <= 'z') return 1;
  if ('A' <= ch && ch <= 'Z') return 1;
  return 0;
}


#ifndef NDEBUG

static int is_valid_variable_name (const char * name) {
  if (!name) return 0;
  if (!is_valid_variable_first_letter (name[0])) return 0;
  for (const char * p = name + 1; *p; p++)
    if (!is_valid_variable_letter (*p)) return 0;
  return 1;
}

#endif

static Variable * new_variable (const char * name) {
  assert (is_valid_variable_name (name));
  if (num_variables == size_variables) enlarge_variables ();
  const uint64_t hash = hash_string (name);
  const uint64_t h = hash & (size_variables - 1);
  Variable ** p, * res;
  for (p = variable_table + h;
       (res = *p) && strcmp (res->name, name);
       p = &res->next)
    ;

  if (!res) {
    *p = res = allocate (sizeof *res);
    res->name = duplicate_string (name);
    res->hash = hash;
    res->next = 0;
    res->count = 1;
    res->level = ++num_variables;
  } else {
    res->count++;
  }
  return res;
}

static void deallocate_variables () {
  for (uint64_t i = 0; i < size_variables; i++) {
    for (Variable * v = variable_table[i], * n; v; v = n) {
      n = v->next;
      deallocate_string (v->name);
      deallocate (v, sizeof *v);
    }
  }
  DEALLOCATE (variable_table, size_variables);
}

static void print_variable (Variable * v, FILE * file) {
  fputs (v->name, file);
}


static int cmp_variable_strcmp (Variable * a, Variable * b) {
  if(a == b) return 0;
  return strcmp(a->name, b->name);
}

static int cmp_variable_strcmp_rev (Variable * a, Variable * b) {
  if(a == b) return 0;
  return -1*strcmp(a->name, b->name);
}

static int cmp_variable_level (Variable * a, Variable * b) {
  if(a == b) return 0;
  if(a->level < b->level) return 1;
  return -1;
}

static int cmp_variable_level_rev (Variable * a, Variable * b) {
  if(a == b) return 0;
  if(a->level > b->level) return 1;
  return -1;
}

static int cmp_variable(Variable *a, Variable*b){
  if (sort == 1) return cmp_variable_strcmp_rev(a,b);
  else if (sort == 2) return cmp_variable_level(a,b);
  else if (sort == 3) return cmp_variable_level_rev(a,b);
  else return cmp_variable_strcmp(a,b);
}


/*------------------------------------------------------------------------*/
// Routines to manipulate powers of variables.

typedef struct Power Power;

// These powers are just pairs of variables and exponents and since
// variables are never deleted and exponents are just machine words we do
// not need any heap manipulation here.

struct Power {
  Variable * variable;
  uint64_t exponent;
};

static Power new_power (Variable * variable, uint64_t exponent) {
  Power res = { variable, exponent };
  return res;
}

static void print_power (Power p, FILE * file) {
  print_variable (p.variable, file);
  if (p.exponent != 1) {
    fputc ('^', file);
    fprintf (file, "%" PRIu64, p.exponent);
  }
}

static int cmp_powers (const Power * a, const Power * b) {
  return cmp_variable (a->variable, b->variable);
}

/*------------------------------------------------------------------------*/

// We provide a global stack of powers for sorting.

static uint64_t num_powers;
static uint64_t size_powers;
static Power * powers;

static void enlarge_powers () {
  size_t new_size_powers = size_powers ? 2*size_powers : 1;
  REALLOCATE (powers, size_powers, new_size_powers);
  size_powers = new_size_powers;
}

static void push_power (Power p) {
  if (size_powers == num_powers) enlarge_powers ();
  powers[num_powers++] = p;
}

static void clear_powers () { num_powers = 0; }

static void deallocate_powers () { DEALLOCATE (powers, size_powers); }

// Sort powers according to the variable order.
static void sort_powers () {
  qsort (powers, num_powers, sizeof *powers,
    (int(*)(const void *, const void *)) cmp_powers);
}

// Merge powers on the stack and flush out those with zero exponent too.

static void merge_powers () {
  Power * a = 0;
  size_t i = 0;
  for (size_t j = 0; j < num_powers; j++) {
    Power * b = powers + j;
    if (!b->exponent) continue;
    if (a && a->variable == b->variable) {
      if (UINT64_MAX - a->exponent < b->exponent)
	die ("maximum exponent range exhausted while merging powers");
      if(exponents) a->exponent += b->exponent;
    } else {
      if (a) assert (cmp_variable (a->variable, b->variable) < 0);
      a = powers + i;
      *a = *b;
      i++;
    }
  }
  num_powers = i;
}

/*------------------------------------------------------------------------*/

// Terms are sorted products of powers of variables.

// They are in principle stored as sorted singly linked lists (through the
// 'rest' pointer) but all lists and suffixes are stored in a hash table to
// make them canonical.  In contrast to variables, which are assumed to be
// live much longer, we support deletion of terms through reference
// counting.  This should save memory and eventually will also allow to
// properly support deletion lines in proofs.

typedef struct Term Term;

struct Term {
  Variable * variable;
  uint64_t exponent;	// non-zero exponent
  Term * rest;	// singly linked list
  uint64_t degree;	// degree of rest + exponent
  uint64_t ref;		// reference counter
  uint64_t hash;	// saved hash value
  Term * next;	// collision chain
};

// Hash table to canonical store terms.

static uint64_t size_terms;
static uint64_t current_terms;
static Term ** term_table;

static void enlarge_terms () {
  uint64_t new_size_terms = size_terms ? 2*size_terms : 1;
  Term ** new_term_table;
  ALLOCATE (new_term_table, new_size_terms);
  for (uint64_t i = 0; i < size_terms; i++) {
    for (Term * m = term_table[i], * n; m; m = n) {
      uint64_t h = m->hash & (new_size_terms - 1);
      n = m->next;
      m->next = new_term_table[h];
      new_term_table[h] = m;
    }
  }
  DEALLOCATE (term_table, size_terms);
  term_table = new_term_table;
  size_terms = new_size_terms;
}


static uint64_t
compute_hash_term (Variable * variable,
                       uint64_t exponent, Term * rest) {
  assert (variable);
  uint64_t res = rest ? rest->hash : 0;
  res *= nonces[0];
  res += exponent;
  res *= nonces[1];
  res += variable->hash;
  res *= nonces[2];
  return res;
}

static void print_term (Term * m, FILE * file) {
  if (!m) fputc ('1', file);
  else {
    Term * n = m;
    while (n) {
      if (n != m) fputc ('*', file);
      print_power (new_power (n->variable, n->exponent), file);
      n = n->rest;
    }
  }
}

static int
match_term (Term * m,
                Variable * variable, uint64_t exponent, Term * rest) {
  if (m->variable != variable) return 0;
  if (m->exponent != exponent) return 0;
  if (m->rest != rest) return 0;
  return 1;
}

static Term * copy_term (Term * m) {
  if (!m) return m;
  assert (m->ref > 0);
  m->ref++;
  assert (m->ref);
  return m;
}

// Statistic counters for terms.

static uint64_t max_terms;
static uint64_t total_terms;
static uint64_t hits_terms;
static uint64_t searched_terms;
static uint64_t collisions_terms;
static uint64_t max_degree;

// First low-level allocation and deallocation of terms.

static Term *
allocate_term (Variable * variable,
                   uint64_t exponent, Term * rest) {
  Term * res = allocate (sizeof *res);
  res->variable = variable;
  res->exponent = exponent;
  res->rest = copy_term (rest);
  if (!rest) res->degree = exponent;
  else if (UINT64_MAX - exponent < rest->degree)
    die ("maximum degree exhausted");
  else res->degree = exponent + rest->degree;
  if (res->degree > max_degree) max_degree = res->degree;
  total_terms++;
  current_terms++;
  if (current_terms > max_terms) max_terms = current_terms;
  return res;
}

static void deallocate_term (Term * m) {
  assert (current_terms);
  current_terms--;
  deallocate (m, sizeof *m);
}

static void deallocate_terms () {
  for (uint64_t i = 0; i < size_terms; i++) {
    for (Term * m = term_table[i], *n; m; m = n) {
      n = m->next;
      deallocate_term (m);
    }
  }
  DEALLOCATE (term_table, size_terms);
}


// Then searching and adding a term extended by one power.


static Term *
new_term (Variable * variable, uint64_t exponent, Term * rest) {
  if (!exponent) return copy_term (rest);
  if (rest) assert (cmp_variable (variable, rest->variable) < 0);
  if (current_terms == size_terms) enlarge_terms ();
  const uint64_t hash = compute_hash_term (variable, exponent, rest);
  const uint64_t h = hash & (size_terms - 1);
  searched_terms++;
  Term * res;
  for (res = term_table[h];
       res && !match_term (res, variable, exponent, rest);
       res = res->next) {
    collisions_terms++;
  }
  if (res) {
    hits_terms++;
    res->ref++;
  } else {
    res = allocate_term (variable, exponent, rest);
    res->ref = 1;
    res->hash = hash;
    res->next = term_table[h];
    term_table[h] = res;
  }
  return res;
}

// Decrements the reference count of a term, and actually deletes a
// term if its reference count goes to zero.  In this case it also
// removes it from the hash table and applies the same procedure to the
// suffix 'rest'.

static void delete_term (Term * m) {
  while (m) {
    assert (m->ref > 0);
    if (--m->ref > 0) break;
    Term * rest = m->rest;
    const uint64_t h = m->hash & (size_terms - 1);
    Term ** p = term_table + h, * n;
    while ((n = *p) != m) assert (n), p = &n->next;
    *p = n->next;
    deallocate_term (m);
    m = rest;
  }
}


static Term * multiply_terms (Term * a, Term * b) {
  if (!a) return copy_term (b);
  if (!b) return copy_term (a);
  const int cmp = cmp_variable (a->variable, b->variable);
  Term * arest, * brest;
  Variable * variable;
  uint64_t exponent;
  if (cmp < 0) {
    arest = a->rest;
    brest = b;
    exponent = a->exponent;
    variable = a->variable;
  } else if (cmp > 0) {
    arest = a;
    brest = b->rest;
    exponent = b->exponent;
    variable = b->variable;
  } else {
    assert (a->variable == b->variable);
    arest = a->rest;
    brest = b->rest;
    if (UINT64_MAX - a->exponent < b->exponent)
      die ("maximum exponent range exhausted while multiplying terms");
    if(!exponents) exponent = a->exponent;
    else exponent = a->exponent + b->exponent;
    variable = a->variable;
  }
  Term * rest = multiply_terms (arest, brest);
  Term * res = new_term (variable, exponent, rest);
  delete_term (rest);
  return res;
}

static int cmp_terms (const Term * a, const Term * b) {
  while (a || b) {
    if (a == b) return 0;
    if (!a && b) return -1;
    if (a && !b) return 1;
    const int res = cmp_variable (a->variable, b->variable);
    if (res) return res;
    assert (a->variable->name == b->variable->name);
    if (a->exponent > b->exponent) return -1;
    if (a->exponent < b->exponent) return 1;
    a = a->rest;
    b = b->rest;
  }
  return 0;
}

static uint64_t degree_term (const Term * a) {
  return a ? a->degree : 0;
}

// Building a term from sorted and merges powers.

static Term * build_term () {
  Term * res = 0;
  int i = num_powers;
  while (i > 0) {
    Power p = powers[--i];
    Term * tmp = new_term (p.variable, p.exponent, res);
    delete_term (res);
    res = tmp;
  }
  return res;
}

/*------------------------------------------------------------------------*/

// Monomials are terms with a coefficient (currently only integers).

typedef struct Monomial Monomial;

struct Monomial {
  mpz_t coeff;		// Local coefficient.
  Term * term;		// Canonical term.
  uint64_t ref;
};

static int sign_of_monomial (Monomial * a) { return mpz_sgn(a->coeff) < 0 ? -1 : 1; }

static int is_zero_monomial (Monomial * a) { return mpz_cmp_si(a->coeff, 0) == 0;}



static Monomial * allocate_monomial () {
  Monomial * res = allocate (sizeof *res);
  res->ref = 1;
  return res;
}

static Monomial * new_monomial (mpz_t coeff, Term * term) {
  Monomial * res = allocate_monomial ();
  mpz_init(res->coeff);
  mpz_set(res->coeff, coeff);
  if (mpz_cmp_si(coeff, 0) == 0) res->term = 0;
  else res->term = copy_term(term);
  return res;
}


static Monomial * copy_monomial (Monomial * a) {
  assert (a->ref > 0);
  a->ref++;
  return a;
}


static void delete_monomial (Monomial * a) {
  assert (a->ref > 0);
  if (--a->ref > 0) return;
  mpz_clear(a->coeff);
  delete_term (a->term);
  deallocate (a, sizeof *a);
}

static Monomial * add_monomials (Monomial * a, Monomial * b) {
  if (is_zero_monomial (a)) return copy_monomial (b);
  if (is_zero_monomial (b)) return copy_monomial (a);
  assert (a->term == b->term);
  Monomial * res = allocate_monomial ();
  mpz_add(res->coeff, a->coeff, b->coeff);
  if (mpz_cmp_si(res->coeff, 0) == 0) res->term = 0;
  else res->term = copy_term(a->term);

  return res;
}

static Monomial * multiply_monomials (Monomial * a, Monomial * b) {
  Monomial * res = allocate_monomial ();
  mpz_mul(res->coeff , a->coeff, b->coeff);
  if (mpz_cmp_si(res->coeff, 0) == 0) res->term = 0;
  else res->term = multiply_terms (a->term, b->term);
  return res;
}


static void print_monomial (Monomial * a, FILE * file) {
  if (!a->term)  mpz_out_str(file, 10, a->coeff);
  else {
    assert (mpz_cmp_si(a->coeff, 0) != 0);
    if (mpz_cmp_si(a->coeff, 1) == 0)
      print_term (a->term, file);
    else if (mpz_cmp_si(a->coeff, -1) == 0)
      fputc ('-', file), print_term (a->term, file);
    else {
      mpz_out_str(file, 10, a->coeff);
      fputc ('*', file);
      print_term (a->term, file);
    }
  }
}

static void print_abs_monomial (Monomial * a, FILE * file) {
  mpz_t aabs;
  mpz_init(aabs);
  mpz_abs(aabs, a->coeff);
  if (!a->term)  mpz_out_str(file, 10, aabs);
  else {
    assert (mpz_cmp_si(a->coeff, 0) != 0);
    if (mpz_cmp_si(a->coeff, 1) == 0 || mpz_cmp_si(a->coeff, -1) == 0)
      print_term (a->term, file);
    else {
      mpz_out_str(file, 10, aabs);
      fputc ('*', file);
      print_term (a->term, file);
    }
  }
  mpz_clear(aabs);
}

static int cmp_monomials (Monomial * a, Monomial * b) {
  const int res = cmp_terms (a->term, b->term);
  if (res) return res;
  return mpz_cmp (a->coeff, b->coeff);
}


/*------------------------------------------------------------------------*/

// Stack to sort and merge monomials.

static size_t num_monomials;
static size_t size_monomials;
static Monomial ** monomials;

static void enlarge_monomials () {
  size_t new_size_monomials = size_monomials ? 2*size_monomials : 1;
  REALLOCATE (monomials, size_monomials, new_size_monomials);
  size_monomials = new_size_monomials;
}

static void push_monomial (Monomial * t) {
  if (size_monomials == num_monomials) enlarge_monomials ();
  monomials[num_monomials++] = t;
}

static void clear_monomials () {
  for (size_t i = 0; i < num_monomials; i++)
    delete_monomial (monomials[i]);
  num_monomials = 0;
}

static void deallocate_monomials () { DEALLOCATE (monomials, size_monomials); }

static int cmp_monomials_for_qsort (const void * p, const void * q) {
  Monomial * a = *(Monomial **) p;
  Monomial * b = *(Monomial **) q;
  return cmp_monomials (a, b);
}

// Sort monomials according to term order.

static void sort_monomials () {
  qsort (monomials, num_monomials, sizeof *monomials, cmp_monomials_for_qsort);
}

// Merge monomials with the same terms and flush zero monomials.

static void merge_monomials () {
  Monomial * a = 0;
  size_t i = 0;
  for (size_t j = 0; j < num_monomials; j++) {
    Monomial * b = monomials[j];
    if (is_zero_monomial (b)) delete_monomial (b);
    else if (a && a->term == b->term) {
      Monomial * c = add_monomials (a, b);
      assert (i > 0);
      assert (monomials[i-1] == a);
      delete_monomial (a);
      delete_monomial (b);
      monomials[i-1] = c;
      a = c;
    } else {
      if (a) assert (cmp_monomials (a, b) < 0);
      monomials[i++] = b;
      a = b;
    }
  }
  num_monomials = i;
}

static uint64_t degree_monomial (Monomial * monomial) {
  return degree_term (monomial->term);
}

/*------------------------------------------------------------------------*/
// Stack to sort and merge monomials.

static size_t num_sum;
static size_t size_sum;
static Monomial ** sum;

static void enlarge_sum () {
  size_t new_size_sum = size_sum ? 2*size_sum : 1;
  REALLOCATE (sum, size_sum, new_size_sum);
  size_sum = new_size_sum;
}

static void push_monomial_sum (Monomial * t) {
  if (size_sum == num_sum) enlarge_sum ();
  sum[num_sum++] = t;
}

static void clear_sum () {
  for (size_t i = 0; i < num_sum; i++)
    delete_monomial (sum[i]);
  num_sum = 0;
}

static void deallocate_sum () { DEALLOCATE (sum, size_sum); }


// Sort monomials according to term order.

static void sort_monomials_sum () {
  qsort (sum, num_sum, sizeof *sum, cmp_monomials_for_qsort);
}

// Merge monomials with the same terms and flush zero monomials.

static void merge_monomials_sum () {
  Monomial * a = 0;
  size_t i = 0;
  for (size_t j = 0; j < num_sum; j++) {
    Monomial * b = sum[j];
    if (is_zero_monomial (b)) delete_monomial (b);
    else if (a && a->term == b->term) {
      Monomial * c = add_monomials (a, b);
      assert (i > 0);
      assert (sum[i-1] == a);
      delete_monomial (a);
      delete_monomial (b);
      sum[i-1] = c;
      a = c;
    } else {
      if (a) assert (cmp_monomials (a, b) < 0);
      sum[i++] = b;
      a = b;
    }
  }
  num_sum = i;
}


/*------------------------------------------------------------------------*/
typedef struct Polynomial Polynomial;

struct Polynomial {
  Monomial * monomial;
  Polynomial * rest;
  int level;
};

static Polynomial * target  = 0;
static Polynomial * result  = 0;


static Polynomial * new_polynomial (Monomial * monomial,  Polynomial * rest, int layer) {
  if (is_zero_monomial (monomial)) return rest;
  if (rest) assert (cmp_monomials (monomial, rest->monomial) < 0);
  Polynomial * res = allocate (sizeof *res);
  res->level = layer;
  res->monomial = copy_monomial (monomial);
  res->rest = rest;
  return res;
}


static void delete_polynomial (Polynomial * a) {
  while (a) {
    Polynomial * rest = a->rest;
    delete_monomial (a->monomial);
    deallocate (a, sizeof *a);
    a = rest;
  }
}

static int sparse_polynomial_printing = 0;

static void print_polynomial (Polynomial * p, FILE * file) {
  if (!p) fputc ('0', file);
  else {
    print_monomial (p->monomial, file);
    for (Polynomial * q = p->rest; q; q = q->rest) {
      int sign = sign_of_monomial (q->monomial);
      if (sparse_polynomial_printing) fputc (' ', file);
      fputc (sign < 0 ? '-' : '+', file);
      if (sparse_polynomial_printing) fputc (' ', file);
      print_abs_monomial (q->monomial, file);
    }
  }
}

// Building a polynomial from sorted and merged monomials.

static Polynomial * build_polynomial () {
  Polynomial * res = 0;
  int i = num_monomials;
  while (i > 0)
    res = new_polynomial (monomials[--i], res, 0);
  return res;
}

static Polynomial * build_sum () {
  Polynomial * res = 0;
  int i = num_sum;
  while (i > 0)
    res = new_polynomial (sum[--i], res, 0);
  return res;
}



static Polynomial * add_polynomials (Polynomial * a, Polynomial * b) {
  for (Polynomial * p = a; p; p = p->rest) push_monomial (copy_monomial(p->monomial));
  for (Polynomial * q = b; q; q = q->rest) push_monomial (copy_monomial(q->monomial));
  sort_monomials ();
  merge_monomials ();
  Polynomial * res = build_polynomial ();
  clear_monomials ();

  return res;
}



static Polynomial * multiply_polynomials (Polynomial * a, Polynomial * b) {
  for (Polynomial * p = a; p; p = p->rest) {
    for (Polynomial * q = b; q; q = q->rest) {
      Monomial * t = multiply_monomials (p->monomial, q->monomial);
      push_monomial (t);

    }
  }
  Polynomial * res = 0;
  sort_monomials ();
  merge_monomials ();
  res = build_polynomial ();
  clear_monomials ();

  return res;
}



static int cmp_polynomials (Polynomial * a, Polynomial * b) {
  const Polynomial * p = a;
  const Polynomial * q = b;
  while (p && q) {
    int res = cmp_monomials (p->monomial, q->monomial);
    if (res) return res;
    p = p->rest;
    q = q->rest;
  }
  if (!p && q) return -1;
  if (p && !q) return 1;
  return 0;
}

static int is_target_polynomial (Polynomial * p) {
  return !cmp_polynomials(target, p);
}




static uint64_t size_polynomial (Polynomial * a) {
  uint64_t res = 0;
  while (a) res++, a = a->rest;
  return res;
}

static uint64_t degree_polynomial (Polynomial * a) {
  uint64_t res = 0;
  while (a) {
    uint64_t tmp = degree_monomial (a->monomial);
    if (tmp > res) res = tmp;
    a = a->rest;
  }
  return res;
}

/*------------------------------------------------------------------------*/

static size_t size_buffer;
static size_t num_buffer;
static char * buffer;

static void enlarge_buffer () {
  size_t new_size_buffer = size_buffer ? 2*size_buffer : 1;
  buffer = reallocate (buffer, size_buffer, new_size_buffer);
  size_buffer = new_size_buffer;
}

static void push_buffer (char ch) {
  if (size_buffer == num_buffer) enlarge_buffer ();
  buffer[num_buffer++] = ch;
}

static void clear_buffer () { num_buffer = 0; }

static void deallocate_buffer () { DEALLOCATE (buffer, size_buffer); }

/*------------------------------------------------------------------------*/

// Character reading routines.

static uint64_t lineno;
static uint64_t columno;
static uint64_t charno;

static int saved_char;
static int char_saved;
static uint64_t last_line_length;

static int next_char (FILE * file) {
  int res;
  if (char_saved) {
    res = saved_char;
    char_saved = 0;
  } else {
#ifdef HAVEUNLOCKEDIO
    res = getc_unlocked (file);
#else
    res = getc (file);
#endif
  }
  if (res == '\n') {
    last_line_length = columno;
    columno = 0;
    lineno++;
  } else if (res != EOF) {
    columno++;
  }
  if (res != EOF) charno++;
  return res;
}

static void prev_char (int ch) {
  assert (!char_saved);
  if (ch == '\n') {
    columno = last_line_length;
    assert (lineno > 0);
    lineno--;
  } else if (ch != EOF) {
    assert (charno > 0);
    charno--;
    assert (columno > 0);
    columno--;
  }
  saved_char = ch;
  char_saved = 1;
}

/*------------------------------------------------------------------------*/

// Scanner.

typedef const char * Token;

static Token END_OF_FILE_TOKEN = "end-of-file";
static Token MINUS_TOKEN       = "minus operator";
static Token PLUS_TOKEN	       = "addition operator";
static Token MULTIPLY_TOKEN    = "multiplication operator";
static Token POWER_TOKEN       = "exponentiation operator";
static Token COLON_TOKEN       = "colon separator";
static Token COMMA_TOKEN       = "comma separator";
static Token SEMICOLON_TOKEN   = "semicolon separator";
static Token NUMBER_TOKEN      = "number";
static Token VARIABLE_TOKEN    = "variable";

static Token token;
static uint64_t lineno_at_start_of_last_token;
static uint64_t columno_at_start_of_last_token;

static void parse_error (const char * file_name, const char * msg, ...) {
  fflush (stdout);
  fprintf (stderr,
    "*** 'NUSS-Checker' parse error in '%s'"
    " line %" PRIu64,
    file_name, lineno_at_start_of_last_token);
  if (buffer[0] && isprint (buffer[0]))
    fprintf (stderr, " at '%s'", buffer);
  else if (token == END_OF_FILE_TOKEN)
    fputs (" at end-of-file", stderr);
  fputs (": ", stderr);
  va_list ap;
  va_start (ap, msg);
  vfprintf (stderr, msg, ap);
  va_end (ap);
  fputc ('\n', stderr);
  fflush (stderr);
  exit (1);
}

static Token new_token (Token t) {
  push_buffer (0);
  token = t;
  return token;
}

static Token next_token (FILE * file, char * name) {
  clear_buffer ();
  for (;;) {
    int ch = next_char (file);
    if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n')
      continue;
    lineno_at_start_of_last_token = lineno;
    columno_at_start_of_last_token = columno;
    if (ch == EOF) return new_token (END_OF_FILE_TOKEN);
    push_buffer (ch);
    if (ch == '-') return new_token (MINUS_TOKEN);
    if (ch == '+') return new_token (PLUS_TOKEN);
    if (ch == '*') return new_token (MULTIPLY_TOKEN);
    if (ch == '^') return new_token (POWER_TOKEN);
    if (ch == ':') return new_token (COLON_TOKEN);
    if (ch == ',') return new_token (COMMA_TOKEN);
    if (ch == ';') return new_token (SEMICOLON_TOKEN);
    if (ch == '{') return next_token(file, name);
    if (ch == '}') return next_token(file, name);
    if ('0' <= ch && ch <= '9') {
      while ('0' <= (ch = next_char (file)) && ch <= '9')
      	push_buffer (ch);
      prev_char (ch);
      return new_token (NUMBER_TOKEN);
    }
    if (is_valid_variable_first_letter (ch)) {
      while (is_valid_variable_letter (ch = next_char (file)))
	       push_buffer (ch);
      prev_char (ch);
      return new_token (VARIABLE_TOKEN);
    }
    if (isprint (ch)) parse_error (name, "invalid character");
    else parse_error (name, "invalid character code 0x%02x", ch);
  }
}

static int is_separator_token (Token t) {
  if (t == COLON_TOKEN) return 1;
  if (t == COMMA_TOKEN) return 1;
  if (t == SEMICOLON_TOKEN) return 1;
  return 0;
}

/*------------------------------------------------------------------------*/

// Parser for polynomials.



static Variable * parse_variable (FILE * file, char * name) {
  Variable * res = new_variable (buffer);
  next_token (file, name);
  return res;
}

static uint64_t parse_exponent (FILE * file, char * name) {
  uint64_t res = 0;
  for (const char * p = buffer; *p; p++) {
    if (UINT64_MAX/10 < res)
      parse_error (name, "invalid exponent");
    res *= 10;
    int ch = *p;
    assert ('0' <= ch);
    assert (ch <= '9');
    uint64_t digit = ch - '0';
    if (res - digit < res)
      parse_error (name, "invalid exponent");
    res += digit;
  }
  next_token (file, name);
  return res;
}

static Term * parse_term (FILE * file, char * name) {
  assert (!num_powers);
  while (token == VARIABLE_TOKEN) {
    Variable * variable = parse_variable (file, name);
    if(!variable) return 0;
    uint64_t exponent;
    if (token == POWER_TOKEN) {
      if (!exponents) parse_error (name, "turn on exponents mode with '--exponents'");
      next_token (file, name);
      if (token != NUMBER_TOKEN)
	      parse_error (name, "exponent missing after '^'");
      exponent = parse_exponent (file, name);
    } else exponent = 1;
    Power p = new_power (variable, exponent);
    push_power (p);
    if (token == MULTIPLY_TOKEN) next_token (file, name);
  }

  sort_powers ();
  merge_powers ();
  Term * res = build_term ();
  clear_powers ();
  return res;
}

static Monomial * parse_monomial (FILE * file, char * name, int sign) {
  mpz_t number;
  mpz_init(number);

  if (token == NUMBER_TOKEN) {
    mpz_set_str(number, buffer, 10);
    next_token(file, name);
  }
  else if (token == VARIABLE_TOKEN) mpz_set_ui (number, 1);
  else parse_error (name, "expected monomial");
  if (sign < 0) {
    mpz_mul_si(number, number, -1);
  }
  if (token == MULTIPLY_TOKEN) next_token (file, name);
  Term * term = parse_term (file, name);

  Monomial * res = new_monomial (number, term);
  delete_term (term);
  mpz_clear (number);
  return res;
}

static Polynomial * parse_polynomial (FILE * file, char * name) {

  int sign;
  if (token == MINUS_TOKEN) {
    next_token (file, name);
    if (token == NUMBER_TOKEN && buffer[0] == '0')
      parse_error (name, "unexpected '0' after '-'");
    sign = -1;
  } else sign = 1;
  assert (!num_monomials);
  for (;;) {
    Monomial * monomial = parse_monomial (file, name, sign);
    push_monomial (monomial);
    if (is_separator_token (token)) break;
    if (token == MINUS_TOKEN) {
      sign = -1;
      next_token (file, name);
    } else if (token == PLUS_TOKEN) {
      sign = 1;
      next_token (file, name);
    } else parse_error (name, "unexpected %s", token);
  }
  sort_monomials ();
  merge_monomials ();
  Polynomial * res = build_polynomial ();
  clear_monomials ();
  return res;
}


/*------------------------------------------------------------------------*/
// Proof statistics.

static uint64_t size_proof;
static uint64_t rep_size_proof;
static uint64_t degree_proof;
static uint64_t length_proof;

static Polynomial ** factors;
static unsigned factors_count = 0;
static unsigned factors_size = 0;


static void enlarge_factors () {
  size_t new_factors_size = factors_size ? 2*factors_size : 1;
  REALLOCATE (factors, factors_size, new_factors_size);
  factors_size = new_factors_size;
}

static void deallocate_factors () {
  assert(factors_count == 0);
  DEALLOCATE (factors, factors_size);
}

static void push_factor(Polynomial * p){
  if(!p) return;
  if(factors_count == factors_size) enlarge_factors();
  factors[factors_count++] = p;
}

static void merge_factors(){
  unsigned i = factors_count;
  if(i == 1) return;
  Polynomial * p = factors[i-1];
  Polynomial * q = factors[i-2];
  if(p->level == q->level){
    Polynomial * add = add_polynomials(p,q);
    add->level = p->level+1;
    delete_polynomial(p);
    delete_polynomial(q);
    factors[i-2] = add;
    factors_count--;
    merge_factors();
  }
}

static Polynomial * add_up_factors(){
  unsigned current_count = 0;
  while(factors_count > 1){
    for(unsigned i = 0; i < factors_count/2; i++){
      Polynomial * p = factors[2*i];
      Polynomial * q = factors[2*i+1];

      assert(p);
      assert(q);
      Polynomial * add = add_polynomials(p,q);
      delete_polynomial(p);
      delete_polynomial(q);

      factors[current_count++] = add;
    }

    if(factors_count % 2 ==1){
      factors[current_count++] = factors[factors_count-1];
    }

    factors_count = current_count;
    current_count = 0;
  }

  assert(factors_count == 1);
  Polynomial * res = factors[0];
  factors_count = 0;
  return res;
}

/*------------------------------------------------------------------------*/

// Original polynomial inference parsing.



static void update_size (Polynomial * p , Polynomial * q) {
    const uint64_t size_p = size_polynomial (p);
    const uint64_t size_q = size_polynomial (q);
    const uint64_t size = size_p * size_q;
    size_proof += size;

    const uint64_t repsize = size_p + size_q;
    rep_size_proof += repsize;
}

static void update_degree (Polynomial * p) {
    const uint64_t degree = degree_polynomial (p);
    if (degree > degree_proof) degree_proof = degree;
}



/*------------------------------------------------------------------------*/

// Parse whole files.


static void parse_target_polynomial () {
  next_token( target_file, target_file_name);
  msg ("reading target polynomial from '%s'", target_file_name);
  target = parse_polynomial (target_file, target_file_name);
  if(verbose)  {
    msg ("target polynomial is");
    fprintf(stdout,"  ");
    print_polynomial(target, stdout);
    fprintf(stdout,"\n\n");
  }
  assert (is_separator_token (token));
  if(next_token (target_file, target_file_name) != END_OF_FILE_TOKEN)
    die ("unexpected %s token at end of file", token);
}


Polynomial * parse_proof () {
  msg ("reading original polynomials from '%s'", poly_file_name);
  msg ("reading co-factors from '%s'", cofactor_file_name);
  uint64_t original = 0, cofactor = 0;
  Polynomial * rem = 0;

  Polynomial * p1 = 0;

  while (next_token (poly_file, poly_file_name) != END_OF_FILE_TOKEN) {
    Polynomial * p = parse_polynomial (poly_file, poly_file_name);
    if (!is_separator_token (token)) parse_error(poly_file_name, "unexpected %s token", token);
    original++;

    next_token(cofactor_file, cofactor_file_name);
    Polynomial * q = parse_polynomial (cofactor_file, cofactor_file_name);


    if (!is_separator_token (token)) parse_error(cofactor_file_name, "unexpected %s token", token);
    cofactor++;

    Polynomial * fac = multiply_polynomials(p, q);
    update_degree (fac);
    update_size (p, q);
    length_proof ++;
    if(verbose) {
      msg("orig poly ");
      fprintf(stdout,"  ");
      print_polynomial(p, stdout);
      fprintf(stdout,"\n");

      msg("co-factor ");
      fprintf(stdout,"  ");
      print_polynomial(q, stdout);
      fprintf(stdout,"\n");

      msg("product ");
      fprintf(stdout,"  ");
      print_polynomial(fac, stdout);
      fprintf(stdout,"\n");
    }
    if (addition == 0){
      push_factor(fac);
      merge_factors();

    } else if(addition == 1){
      if(p1){
        Polynomial * add = add_polynomials(p1, fac);
        push_factor(add);
        delete_polynomial(fac);
        delete_polynomial(p1);
        p1 = 0;

      } else p1 = fac;
    } else if (addition == 2){

      if (rem){
        Polynomial * tmp = add_polynomials(rem, fac);
        delete_polynomial(rem);
        delete_polynomial(fac);
        rem = tmp;
      } else {
        rem = fac;
      }
    } else {
      Polynomial * tmp = fac;
      while(tmp){
        push_monomial_sum(copy_monomial(tmp->monomial));
        tmp = tmp->rest;
      }
      delete_polynomial(fac);
    }

    delete_polynomial(p);
    delete_polynomial(q);
  }

  if(addition == 0 || addition == 1) {
    if(p1) push_factor(p1);
    rem = add_up_factors();
  }
  else if (addition == 3) {
    sort_monomials_sum ();
    merge_monomials_sum ();
    rem = build_sum ();
    clear_sum ();

  }

  msg ("found %" PRIu64 " original polynomials in '%s'", original, poly_file_name);
  msg ("found %" PRIu64 " co-factor polynomials in '%s'", cofactor, cofactor_file_name);
  return rem;
}

/*------------------------------------------------------------------------*/

static double percent (double a, double b) { return b ? 100.0*a/b : 0; }
static double average (double a, double b) { return b ? a/b : 0; }

/*------------------------------------------------------------------------*/

static void init () {
  init_nonces ();
}

static void deallocate_all () {
  deallocate_factors();

  delete_polynomial(target);
  delete_polynomial(result);
  deallocate_terms ();
  deallocate_sum ();
  deallocate_monomials ();
  deallocate_powers ();
  deallocate_variables ();
  deallocate_buffer ();
  assert (!current_allocated_bytes);
}

static void reset () {
  deallocate_all ();
}

/*------------------------------------------------------------------------*/



static void print_statistics () {
  msg ("proof length %" PRIu64 " (number of factors)", length_proof);
  msg ("proof size %" PRIu64 " (on average %.1f terms per factor)",
    size_proof, average (size_proof, length_proof));
  msg ("proof representation size %" PRIu64 " (on average %.1f terms per polynomial)",
    rep_size_proof, average (rep_size_proof, 2*length_proof));
  msg ("proof degree %" PRIu64 " (internal maximum degree %" PRIu64 ")",
    degree_proof, max_degree);
  msg ("maximum %" PRIu64 " of total %" PRIu64 " terms (%.0f%%)",
    max_terms, total_terms,
    percent (max_terms, total_terms));
  msg ("searched %" PRIu64 " terms %.0f%% hits %.1f average collisions",
    searched_terms,
    percent (hits_terms, searched_terms),
    average (collisions_terms, searched_terms));
  msg ("maximum %zu bytes allocated (%.1f MB)",
    max_allocated_bytes, max_allocated_bytes/(double)(1<<20));
#ifdef HAVEGETRUSAGE
  struct rusage u;
  if (getrusage (RUSAGE_SELF, &u)) return;
  size_t s = ((size_t) u.ru_maxrss) << 10;
  msg ("maximum resident set size %zu bytes (%.1f MB)",
    s, s/(double)(1<<20));
  double t = u.ru_utime.tv_sec + 1e-6 * u.ru_utime.tv_usec;
  t += u.ru_stime.tv_sec + 1e-6 * u.ru_stime.tv_usec;
  msg ("process time %.3f seconds", t);
#endif
}


/*------------------------------------------------------------------------*/

// Main routine for stand alone checker.

static void banner () {
  msg ("NUSS-Checker Version " VERSION);
  msg ("Nullstellensatz Proof Checker");
  msg ("Copyright (C) 2020, Daniela Kaufmann, Johannes Kepler University Linz");
}

int main (int argc, char ** argv) {

  int sort_chosen = 0, add_chosen = 0;

  for (int i = 1; i < argc; i++) {
    if (!strcmp (argv[i], "-h") ||
        !strcmp (argv[i], "--help"))
      fputs (usage, stdout), exit (0);
    else if (!strcmp (argv[i], "-t") ||
             !strcmp (argv[i], "--no-target"))
      check_target = 0;
    else if (!strcmp (argv[i], "-e") ||
             !strcmp (argv[i], "--use-exponents"))
      exponents = 1;
    else if (!strcmp (argv[i], "-a0")){
      if(add_chosen++) die("cannot combine '-a0', '-a1', '-a2' or '-a3'");
      addition = 0;
    }
    else if (!strcmp (argv[i], "-a1")){
      if(add_chosen++) die("cannot combine '-a0', '-a1', '-a2' or '-a3'");
      addition = 1;
    }
    else if (!strcmp (argv[i], "-a2")){
      if(add_chosen++) die("cannot combine '-a0', '-a1', '-a2' or '-a3'");
      addition=2;
    }
    else if (!strcmp (argv[i], "-a3")){
      if(add_chosen++) die("cannot combine '-a0', '-a1', '-a2' or '-a3'");
      addition = 3;
    }
    else if (!strcmp (argv[i], "-v") ||
             !strcmp (argv[i], "--verbose"))
      verbose = 1;

    else if (!strcmp (argv[i], "-s0")){
      sort = 0;
      if(sort_chosen++) die("cannot combine '-s0', '-s1', '-s2' or '-s3'");
    }
    else if (!strcmp (argv[i], "-s1")){
      sort = 1;
      if(sort_chosen++) die("cannot combine '-s0', '-s1', '-s2' or '-s3'");
    }
    else if (!strcmp (argv[i], "-s2")){
      sort = 2;
      if(sort_chosen++) die("cannot combine '-s0', '-s1', '-s2' or '-s3'");
    }
    else if (!strcmp (argv[i], "-s3")){
      sort = 3;
      if(sort_chosen++) die("cannot combine '-s0', '-s1', '-s2' or '-s3'");
    }
    else if (argv[i][0] == '-')
      die ("invalid command line option '%s' (try '-h')", argv[i]);
    else if (target_file_name)
      die ("too many command line arguments (try '-h')");
    else if (cofactor_file_name)
      target_file_name = argv[i];
    else if (poly_file_name) cofactor_file_name = argv[i];
    else poly_file_name = argv[i];
  }

  if(!target_file_name) check_target = 0;

  banner ();
  init ();


  if (sort == 1) msg("sorting according to reverse strcmp");
  else if (sort == 2) msg("sorting according to input order");
  else if (sort == 3) msg("sorting according to reverse input order");
  else  msg("sorting according to strcmp");

  if(!addition) msg("addition in tree approach, depth first");
  else if (addition == 1) msg("addition in tree approach, breadth first");
  else if (addition == 2) msg("addition in sequence");
  else  msg("addition by sorting one single stack");


  if (target_file_name && check_target) {
    msg ("checking target enabled");
    target_file = fopen (target_file_name, "r");
    if (!target_file) die ("can not open '%s' for reading", target_file_name);

    lineno = 1;
    columno = 0;
    charno = 0;

    parse_target_polynomial (target_file);
  }
  if(cofactor_file_name){
      poly_file = fopen (poly_file_name, "r");
      if (!poly_file) die ("can not open '%s' for reading", poly_file_name);

      cofactor_file = fopen (cofactor_file_name, "r");
      if (!cofactor_file) die ("can not open '%s' for reading", cofactor_file_name);

    lineno = 1;
    columno = 0;
    charno = 0;

    result = parse_proof ();
  } else die ("too few command line arguments (try '-h')");

  print_statistics ();

  if(check_target){
    int found = is_target_polynomial(result);

    if (found) msg ("TARGET CHECKED");
    else {
      msg ("TARGET NOT INFERRED");
      msg("FINAL RESULT IS ");
      print_polynomial(result, stdout);
      fprintf(stdout, "\n");

    }
  } else {
    msg("FINAL RESULT IS ");
    print_polynomial(result, stdout);
    fprintf(stdout, "\n");
  }

  reset ();

  fclose(poly_file);
  fclose(cofactor_file);
  if (check_target) fclose(target_file);

  return 0;
}
